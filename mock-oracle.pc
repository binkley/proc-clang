#include "proc-gcc.h"

#include <stdarg.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <stdio.h>

#include <sqlca.h>

#include "mock-oracle.h"

typedef struct _record {
    int n_fields;
    data_field_t fields[20];
} record_t;

static record_t _records[20];
static int _n_records;
static int _x_records;

static void
record_field(const data_field_t *field)
{
    record_t *record = &_records[_n_records];
    data_field_t *current = &record->fields[record->n_fields];
    current->data = field->data;
    current->len = field->len;
    ++record->n_fields;
}

void
RESET_DATA()
{
    _n_records = 0;
    // TODO: free malloc'd memory in fields
    _x_records = 0;
}

void
TEST_DATA(const int n, ...)
{
    int i;
    va_list ap;
    va_start(ap, n);
    for (i = 0; i < n; ++i)
        record_field(va_arg(ap, data_field_t *));
    va_end(ap);
    ++_n_records;
}

static const data_field_t *
make_field(const void *p, const size_t len)
{
    data_field_t *field = (data_field_t *) malloc(sizeof(data_field_t));
    field->len = len;
    field->data = malloc(len);
    memcpy(field->data, p, len);
    return field;
}

const data_field_t *
_STRING(const char *s)
{
    return make_field((void *) s, strlen(s) + 1);
}

const data_field_t *
_INT(const int i)
{
    return make_field((void *) &i, sizeof(int));
}

const data_field_t *
_FLOAT(const float f)
{
    return make_field((void *) &f, sizeof(float));
}

static void
recv_eof(const struct sqlexd *sqlstm)
{
    sqlca.sqlcode = 1403;
}

static void
recv_field(void *slot, const data_field_t *field)
{
    memcpy(slot, field->data, field->len);
}

static void
recv_record(struct sqlexd *sqlstm, const record_t *record)
{
    int i, x;
    for (i = 0, x = record->n_fields; i < x; ++i)
        recv_field(sqlstm->sqhstv[i], &record->fields[i]);
}

void
sqlcxt(void **ignored, unsigned int *sqlctx, struct sqlexd *sqlstm,
        const struct sqlcxp *sqlfpn)
{
    if (0 == sqlstm->arrsiz)
        return;
    if (_n_records == _x_records) {
        recv_eof(sqlstm);
        return;
    }
    const record_t *record = &_records[_x_records++];
    recv_record(sqlstm, record);
}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
static void
_force_proc_code_generation()
{
    char *connect = 0, *username = 0, *password = 0;

    EXEC SQL CONNECT :username IDENTIFIED BY :password
        USING :connect;
}
#pragma clang diagnostic pop
